# 计算机组成原理 - 定点整数的原码补码运算（待验证）

[toc]

## 〇、环境

对象 | 运算
:----- |  :-----
定点整数原码、定点整数补码 | 移位、加、减、乘、除

**原码定义**：

$x=\begin{cases}
x &0\le x < 2^{n}
\\2^{n}-x &-2^{n} < x \le 0
\end{cases}$

其中，n为x的位数，最终原码有n+1位。

**定义分析**：当真值为正时，原码即为真值的二进制形式，但是在二进制最高位添加一个0作为符号位（定义没有体现）。当真值为负时，去掉原码二进制形式的负号，在二进制最高位添加一个1作为符号位。

**伸展和收缩**：由定义分析可知，x宽度变化时，非符号部分添加或移除高位0（也即整数的二进制形式调整宽度），符号部分不变。在形式上，无论正负，都是在最高位新增或移除0。

> 例0-1 求$11_b$的8位原码表示  
> 解：为011，扩展到8位为0000 0011。  

> 例0-2 求$-11_b$的8位原码表示  
> 解：100-(-11)=111，扩展到8位为0000 0111。  

**补码定义**：

$x=\begin{cases}
x &0\le x < 2^n
\\2^{n+1}+x &-2^n \le x < 0
\end{cases}$

其中n为x的位数，最终有n+1位（去掉一定为0的最高位）。

**定义分析**：当真值为正时，保留真值的二进制形式，并在最高位添加一个0作为符号位。当真值为负时，则与10...0(共n+2位)相加，联系反码的特点，即将真值负号移除后每位取反，然后加1，然后最高位添加1作为符号位。

**伸展与收缩**：由定义分析，当真值为正时，则和原码一致，添加0即可。当为负时，扩展添0，取反后则为添1，加1时不会影响扩展位（因为负值的二进制形式必不全为0），最后保持符号位不变。形式上，正值在最高位添加和删除0，负值扩在最高位添加和删除1。

> 例0-3 求11的8位补码表示  
> 解：为011，扩展到8位为0000 0011。  

> 例0-4 求-11的8位补码表示  
> 解：为1000-11=0101，即101，扩展到8位为1111 1101。  
> 还可以利用性质来求：^11=00，00+1=01，添加符号位即101。  

## 一、移位运算

移位的数学意义为乘2和除2。

### 1.算术移位

识别符号的移位，符号位不变。

编码 | 机器数（真值） | 算术左移（真值） | 算术右移（真值）
:-- | :-- | :-- | :--
原码 | 0001(1) | 0010(2) | 0000(0)
原码 | 0100(4) | 0000(0) | 0010(2)
原码 | 1001(-1) | 1010(-2) | 1000(-0)
原码 | 1100(-4) | 1000(-0) | 1010(-2)
补码 | 1001(-7) | 1010(-6) | 1100(-4)
补码 | 1100(-4) | 1000(-8) | 1010(-6)

### 2.逻辑移位

不识别符号的移位。

### 3.移位总结

对于原码和补码，算术移位和逻辑移位，左移和右移，仅有**负数的补码形式**在右移时填充1，其余均为填0。

对于正数、原码负数，左移掉1则引起错误，右移掉1则引起偏差。  
**对于补码负数，左移掉0则引起错误，右移掉0则引起偏差**。  

## 二、加法和减法

### 1.原码加、减法

直接根据符号位进行加减即可。将符号位提取出来，然后转换成“正值+正值”或者“正值-正值”的形式。

参数1（真值） | 参数2（真值） | 运算 | 结果（真值）
:-- | :-- | :-- | :--
0100(4) | 0001(1) | + | 0101(5)
0100(4) | 1001(-1) | + | 0011(3)

### 2.补码加法

若有 $A>0,B>0$ ， 则

$[A]_补=A,[B]_补=B，$即 $[A]_补+[B]_补=A+B=[A+B]_补$。

若有 $A>0,B<0$ ，则

$[A]_补=A,[B]_补=2^{n+1}+B,[A+B]_补=(A+B)或2^{n+1}+(A+B)$ ，即 $[A]_补+[B]_补=[A+B]_补(mod\space2^{n+1})$

其它情况类似，不重复。

即**补码加法公式**：  
$$[A+B]_补=[A]_补+[B]_补\space(mod\space2^{n+1})$$

公式说明：  
右边的加法为二进制加法，不考虑符号位。相加后去掉溢出位，即得到补码加法的结果（当然也是补码形式）。也即**两个真值的补码直接相加即得两个真值的和的补码（宽度不变）**。  

> 例2.2-1 计算 $0001_补+1111_补$ 。  
解：$0001+1111=1,0000$，去掉溢出位，即结果为 $0000$ 。  

> 例2.2-2 计算 $1111_补+1110_补$ 。  
解：$1111+1110=11101$，去掉溢出位，即结果为 $1101$  

### 3.补码减法

将减法转换为加法进行运算。

因为 $A-B=A+(-B)，（B>0）$ ，

即 $[A-B]_补=[A+(-B)]_补$ ，

即补码的减法公式 $$[A-B]_补=[A]_补 + [-B]_补\space(mod\space 2^{n+1})$$

其中 $[-B]_补=\text{\textasciicircum}[B]_补+1$ 。^表示按位取反。

> 例2.3-1 计算 $1111_补-0001_补$ 。  
解：$\text{\textasciicircum}[0001]+1=1110+1=1111，故1111-0001=1111+1111=11110$ ，去掉溢出位，结果为$1110$。  

## 三、乘法

### 1.原码乘法

将符号位分离，单独计算正值的乘法，最后将符号计算并赋予结果。

正值的乘法和十进制乘法基本一致，在逻辑上表现为部分积累加并移位。

> 例3.1-1 计算 $0011_原\times0010_原$ 。  
解：直观结果为3x2=6=0110。  
原码乘法计算过程：  
$$\begin{aligned}
&0011
\\\times\space&0010
\\&0000
\\0&011
\\=\space0&0110
\end{aligned}
$$

>例3.1-2 计算 $0111_原\times0111_原$ 。  
解：直观结果为7x7=49=00110001。  
原码乘法计算过程：  
$$
\begin{aligned}
&0111
\\\times\space&0111
\\&0111
\\0&111
\\01&11
\\=\space11&0001
\end{aligned}
$$

2.补码乘法

先讨论补码乘法**乘数为正的情况**。

对 $[X]_补\times[Y]_补$ ，假设 $Y>0$ ，则有

$[X]_补=2^{n+1}+X\space(mod\space 2^{n+1}),[Y]_补=Y$

$[X]_补\times[Y]_补=(2^{n+1}+X)\cdot Y\space(mod\space2^{n+1})
\\=X\cdot Y\space(mod\space2^{n+1})
\\=[X\cdot Y]_补\space(mod\space2^{n+1})$

这说明，当 $Y$ 为正时，补码的乘法即为各自补码直接二进制乘法的结果（去除溢出位）。

> 例3.2-1 计算 $1111_补\times0011_补$ 。  
> 解：直观结果为(-1)x(3)=-3=1101。  
> $$
> \begin{aligned}
> &1111
> \\\times\space&0011
> \\&1111
> \\1&111
> \\=\space10&1101
> \end{aligned}
> $$  
> 去除溢出位即为 $1101$  

再讨论**乘数为负的情况**。

此时有 $[Y]_补=2^{n+1}+Y$ ，也即 $Y=[Y]_补-2^{n+1}$ 。

即 $X\cdot Y=X\cdot ([Y]_补-2^{n+1})$ 。

记 $[Y]_补=1y_1y_2...y_n=0y_1y_2...y_n+2^n$ 。

则 $X\cdot Y=X\cdot(0y_1y_2...y_n-2^{n})
\\=X\cdot 0y_1y_2...y_n-X\cdot 2^n$ 。

即 $[X\cdot Y]_补=[X\cdot 0y_1y_2...y_n-X\cdot 2^n]_补$ 

由补码减法公式，分解右式，有

$[X\cdot Y]_补=[X\cdot 0y_1y_2...y_n]_补+[-X\cdot 2^n]_补\space(mod\space2^{n+1})$

记 $X=x_1x_2...x_n$ ，则 $[-X\cdot 2^n]_补=[-x_1x_2...x_n0_10_2...0_n]_补
\\=1\text{\textasciicircum}(x_1x_2...x_n)1_11_2...1_n+1
\\=x_n0_10_2...0_n
\\=x_n\times2^n\space(mod\space2^{n+1})$

$0.y_1y_2...y_n$ 是一个补码形式的正数，可应用补码正乘数规律进行分解。故

$[X\cdot Y]_补=[X]_补\cdot 0y_1y_2...y_n+x_n\times2^n\space(mod\space2^{n+1})$

也即如果乘数为负，则将乘数去掉符号位与被乘数二进制相乘，然后加上 $x_n\times2^n$ 即得乘积的补码。

>例3.2-2 计算 $0011_补\times1110_补$ 的8位补码表示  
>解：直观结果为 $3\times(-2)=-6=1010$  
>解法：  
>$x_n\times2^n$=1000  
> $$
> \begin{aligned}
> &0011
> \\\times\space&0110
> \\0&011
> \\00&11
> \\=\space01&0010
> \\+\space&1000
> \\=\space01&1010
> \end{aligned}
> $$  
> 保留4位为 $1010$，扩展到8位为 $1111\space1010$。  

>例3.2-3 计算 $1110_补\times 1110_补$ 的8位补码表示  
>解：直观结果为 $-2\times-2=4=0100=0000,0100$  
>解法：  
>$x_n\times2^n=0$
>$$
>\begin{aligned}
>&1110
>\\\times\space&0110
>\\1&110
>\\11&10
>\\=\space101&0100
>\\+\space&0000
>\\=\space101&0100
>\end{aligned}
>$$  
>保留4位为0100，扩展到8位为 $0000,0100$ 。  

总结：  
$$
[X\cdot Y]_补=
\begin{cases}
[X]_补\times[Y]_补\space(mod\space2^{n+1}) &Y\ge0
\\ [X]_补\cdot 0y_1y_2...y_n+x_n\times2^n\space(mod\space2^{n+1}) \space &Y<0
\end{cases}
$$

记 $Y=y_0y_1y_2...y_n$，则可以简化为  
$$
[X\cdot Y]_补=[X]_补\cdot 0y_1y_2...y_n+y_0\cdot x_n\times2^n\space(mod\space2^{n+1}) \space
$$
